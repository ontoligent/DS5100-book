{
  "hash": "36c1b756ef64917d22e7ca4ffffe2e5c",
  "result": {
    "markdown": "# NB: Introducing Tibbles\n\n> Based on [Wikham and Grolemund 2017](https://r4ds.had.co.nz/index.html)\n\n## The Tidyverse\n\nTidyverse is a collection of essential R packages for data science.\n\nThe packages included in the Tidyverse are designed to support the pipeline of activities associated with data science, such as filtering, transforming, visualizing, etc.\n\n![](images/paste-EE0D9577.png)\n\nTidyverse was created by **Hadley Wickham** and his team with the aim of providing all these utilities to clean and work with data.\n\nHere's a graphic of the packages associated with the TV:\n\n![](images/paste-32BD3A67.png)\n\nWe are going to focus on `dplyr` today and `ggplot` tomorrow.\n\n## Dplyr\n\nDplyr introduces **new set of functions** that make working with data more intuitive.\n\n-   It does this by introducing a set of functions that work together well to produce pipelines of actions.\n\nBut as important, it introduces a **vocabulary** for talking about data.\n\n-   This makes it possible to imagine solutions verbally, and then to implement them in code.\n\nTo use the TV, we usually import everything:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching packages --------------------------------------- tidyverse 1.3.2 --\nv ggplot2 3.3.5     v purrr   1.0.1\nv tibble  3.2.1     v dplyr   1.1.1\nv tidyr   1.2.1     v stringr 1.5.0\nv readr   2.1.3     v forcats 1.0.0\n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n\n## Piping with `%>%`\n\nJust a quick note about this **odd looking** operator that you will start to see.\n\nOne of the key elements of the TV is the use of **piping**, or the ability of to pass the return values of one function to another, with without have to nest functions.\n\nFor example, instead of something like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"Hello\"\nb <- \"World\"\n\nvar1 <- c(a, b)\nvar2 <- paste(var1)\nprint(var2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"World\"\n```\n:::\n:::\n\n\n\nOr this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(c(a,b)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"World\"\n```\n:::\n:::\n\n\n\nWe can do:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(a, b) %>%\n  paste() %>%\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"World\"\n```\n:::\n:::\n\n\n\nAlthough the last pattern is longer than the preceding, it is much easier to read and write, especially when we are working with several connected functions.\n\nThis is similar to **method chaining** in Python, but is more pervasive.\n\n-   In Python you can do it with individual objects that return themselves (as it were).\n-   In TV, you can apply it to **any two methods** so long as it makes sense to pass the output of as the input of another.\n-   Basically, the output of one function becomes the first argument of the following the `%>%`.\n\nIt is similar to the pipe operator `|` in Unix shells.\n\n# Tibbles\n\nDplyr can work with different rectangular data structures:\n\n-   Data frames\n-   Tibbles\n-   Data.tables (see [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html))\n\nThe foundational data structure of the TV is the **tibble**.\n\nTibbles are data frames, but they tweak some older behaviors to make your life a little easier.\n\nTo learn more about tibbles, check out the vignette:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette(\"tibble\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nstarting httpd help server ... done\n```\n:::\n:::\n\n\n\n## Creating tibbles\n\nIf you need to make a tibble \"by hand\", you can use `tibble()` or `tribble()`.\n\n`tibble()` works by assembling individual vectors, **column-wise** operation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 5)\ny <- c(\"a\", \"b\", \"h\")\ntibble(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n      x y    \n  <dbl> <chr>\n1     1 a    \n2     2 b    \n3     5 h    \n```\n:::\n:::\n\n\n\nYou can also optionally name the inputs, provide data inline with `c()`, and perform computation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x1 = x,\n  x2 = c(10, 15, 25),\n  y = sqrt(x1^2 + x2^2)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n     x1    x2     y\n  <dbl> <dbl> <dbl>\n1     1    10  10.0\n2     2    15  15.1\n3     5    25  25.5\n```\n:::\n:::\n\n\n\nEvery column in a data frame or tibble must be same length, so you'll get an error if the lengths are different:\n\n\n\n\n\n\n\nAs the error suggests, individual values will be recycled to the same length as everything else:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:5,\n  y = \"a\",\n  z = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n      x y     z    \n  <int> <chr> <lgl>\n1     1 a     TRUE \n2     2 a     TRUE \n3     3 a     TRUE \n4     4 a     TRUE \n5     5 a     TRUE \n```\n:::\n:::\n\n\n\n## Tribbles\n\nAnother way to create a tibble is with `tribble()`, which short for **transposed tibble**.\n\n`tribble()` is customized for data entry in code: **column headings start with `~`** and **entries are separated by commas**.\n\nThis makes it possible to lay out small amounts of data in an easy to read form:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n  ~x, ~y, ~z,\n  \"a\", 2, 3.6,\n  \"b\", 1, 8.5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  x         y     z\n  <chr> <dbl> <dbl>\n1 a         2   3.6\n2 b         1   8.5\n```\n:::\n:::\n\n\n\nFinally, if you have a regular `data frame` you can turn it into to a tibble with `as_tibble()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# i 22 more rows\n```\n:::\n:::\n\n\n\nThe inverse of `as_tibble()` is `as.data.frame()`; it converts a tibble back into a regular `data.frame`.\n\n## Non-syntactic names\n\nIt's possible for a tibble to have column names that are not valid R variable names, names that are **non-syntactic**.\n\nFor example, the variables might not start with a letter or they might contain unusual characters like a space.\n\nTo refer to these variables, you need to surround them with backticks, `` ` ``:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(\n  `:)` = \"smile\", \n  ` ` = \"space\",\n  `2000` = \"number\"\n)\ntb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n  `:)`  ` `   `2000`\n  <chr> <chr> <chr> \n1 smile space number\n```\n:::\n:::\n\n\n\nYou'll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.\n\n# Tibbles vs. data.frame\n\nThere are two main differences in the usage of a tibble vs. a classic `dat frame`:\n\n-   **printing** and **subsetting**.\n\nIf these difference cause problems when working with older packages, you can turn a tibble back to a regular data frame with `as.data.frame()`.\n\n## Printing\n\nThe print method:\n\n-   Only the first 10 rows\n\n-   All the columns that fit on screen.\n\nThis makes it much easier to work with large data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  a = lubridate::now() + runif(1e3) * 86400,\n  b = lubridate::today() + runif(1e3) * 30,\n  c = 1:1e3,\n  d = runif(1e3),\n  e = sample(letters, 1e3, replace = TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 x 5\n   a                   b              c      d e    \n   <dttm>              <date>     <int>  <dbl> <chr>\n 1 2023-06-19 18:40:15 2023-06-21     1 0.150  j    \n 2 2023-06-19 13:10:40 2023-06-25     2 0.556  j    \n 3 2023-06-19 10:53:19 2023-06-20     3 0.895  l    \n 4 2023-06-20 07:11:06 2023-06-25     4 0.295  q    \n 5 2023-06-20 01:56:41 2023-06-25     5 0.658  n    \n 6 2023-06-19 13:22:02 2023-07-07     6 0.635  n    \n 7 2023-06-20 10:19:22 2023-06-21     7 0.0475 q    \n 8 2023-06-20 00:48:16 2023-07-07     8 0.620  i    \n 9 2023-06-19 22:28:22 2023-07-18     9 0.906  p    \n10 2023-06-19 18:35:02 2023-06-30    10 0.611  l    \n# i 990 more rows\n```\n:::\n:::\n\n\n\nWhere possible, **tibbles also use color** to draw your eye to important differences.\n\nOne of the most important distinctions is between the string `\"NA\"` and the missing value, `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = c(\"NA\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 1\n  x    \n  <chr>\n1 NA   \n2 <NA> \n```\n:::\n:::\n\n\n\nTibbles are designed to avoid overwhelming your console when you print large data frames.\n\nBut **sometimes you need more output** than the default display.\n\nThere are a few options that can help.\n\nFirst, you can explicitly `print()` the data frame and control the number of rows (`n`) and the `width` of the display.\n`width = Inf` will display all columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nflights %>%\n  print(n = 10, width = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 x 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n   arr_delay carrier flight tailnum origin dest  air_time distance  hour minute\n       <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl>    <dbl> <dbl>  <dbl>\n 1        11 UA        1545 N14228  EWR    IAH        227     1400     5     15\n 2        20 UA        1714 N24211  LGA    IAH        227     1416     5     29\n 3        33 AA        1141 N619AA  JFK    MIA        160     1089     5     40\n 4       -18 B6         725 N804JB  JFK    BQN        183     1576     5     45\n 5       -25 DL         461 N668DN  LGA    ATL        116      762     6      0\n 6        12 UA        1696 N39463  EWR    ORD        150      719     5     58\n 7        19 B6         507 N516JB  EWR    FLL        158     1065     6      0\n 8       -14 EV        5708 N829AS  LGA    IAD         53      229     6      0\n 9        -8 B6          79 N593JB  JFK    MCO        140      944     6      0\n10         8 AA         301 N3ALAA  LGA    ORD        138      733     6      0\n   time_hour          \n   <dttm>             \n 1 2013-01-01 05:00:00\n 2 2013-01-01 05:00:00\n 3 2013-01-01 05:00:00\n 4 2013-01-01 05:00:00\n 5 2013-01-01 06:00:00\n 6 2013-01-01 05:00:00\n 7 2013-01-01 06:00:00\n 8 2013-01-01 06:00:00\n 9 2013-01-01 06:00:00\n10 2013-01-01 06:00:00\n# i 336,766 more rows\n```\n:::\n:::\n\n\n\nYou can also **control the default print behavior** by setting options:\n\n-   `options(tibble.print_max = n, tibble.print_min = m)`: if more than `n` rows, print only `m` rows.\n-   Use `options(tibble.print_min = Inf)` to always show all rows.\n-   Use `options(tibble.width = Inf)` to always print all columns, regardless of the width of the screen.\n\nYou can see a complete list of options by looking at the package help with `package?tibble`.\n\n## Using `View()`\n\nA final option is to use RStudio's built-in data viewer to get a scrollable view of the complete dataset.\nThis is also often useful at the end of a long chain of manipulations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n  View()\n```\n:::\n\n\n\n## Extracting variables\n\nSo far all the tools you've learned have worked with complete data frames.\n\nIf you want to pull out a single variable, you can use `dplyr::pull()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(\n  id = LETTERS[1:5],\n  x1  = 1:5,\n  y1  = 6:10\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntb %>%  \n  pull(x1) # by name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntb %>%  \n  pull(1)  # by position\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n```\n:::\n:::\n\n\n\n`pull()` also takes an optional `name` argument that specifies the column to be used as names for a named vector, which you'll learn about in [Chapter -@sec-vectors].\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb %>%  \n  pull(x1, name = id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA B C D E \n1 2 3 4 5 \n```\n:::\n:::\n\n\n\nYou can also use the base R tools `$` and `[[`.\n`[[` can extract by name or position; `$` only extracts by name but is a little less typing.\n\nExtract by name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb$x1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\ntb[[\"x1\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nExtract by position:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n```\n:::\n:::\n\n\n\nCompared to a `data frame`, **tibbles are more strict**: they never do partial matching, and they will generate a warning if the column you are trying to access does not exist.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tibbles complain a lot:\ntb$x\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `x`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\ntb$z\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown or uninitialised column: `z`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data frame use partial matching and don't complain if a column doesn't exist\ndf <- as.data.frame(tb)\ndf$x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\ndf$z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n\nFor this reason we sometimes joke that **tibbles are lazy and surly**: they do less and complain more.\n\n## Subsetting\n\nLastly, there are some important differences when using `[`.\n\nWith `data.frame`s, `[` sometimes returns a `data.frame`, and sometimes returns a vector.\n\n-   This is a common source of bugs.\n\nWith tibbles, **`[` always returns another tibble**.\n\n-   This can sometimes cause problems when working with older code.\n\n-   If you hit one of those functions, just use `as.data.frame()` to turn your tibble back to a `data.frame`.\n",
    "supporting": [
      "M11-01-Tibbles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}